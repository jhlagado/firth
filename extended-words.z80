;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Firth extended (non-standard) words
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

defword "#base",5,0,hashbase            ; n --      ; switch to basel for one word
    rst $08
    dw base,fetch                       ; 16 base0
    dw swap, base, store                ; base0
    dw lit, $20, word, count            ; base0 addr length
    dw dup, zEqual
    cIf
        dw drop, drop                   ; base0
    cElse
        dw number                       ; base0 value error
        dw zNotEqual                    ; base0 value
        dw dup, dot
        cif
            dw drop                     ; base0
            dw litstr
            .pstr "Error: parsing"
            dw type
        cElse
            dw swap                     ; value base0
        cEndIf
    cEndif
    dw base, store                      ; restore base0
    EXIT

defword "#h",2,0,hashh                  ; switch to hex for one word
    rst $08                             ; enter forth
    dw lit,16,hashbase
    EXIT

defword "#d",2,0,hashd                  ; switch to decimal for one word
    rst $08                             ; enter forth
    dw lit,10,hashbase
    EXIT

defword "define:",7,0,defineColon
    rst $08                             ; enter forth
    dw create                           ; create the dictionary entry / header
    dw here,fetch                       ; back up 3 bytes to start of data area
    dw lit, 3, minus
    dw here, store
    dw lit, jp_opcode, ccomma          ; write z80 jp opcode to word
    dw comma                            ; compile address TOS
    EXIT                             ; return from the function.

defword "{",1,msk_immed,lbrace
    rst $08                             ; enter forth
    dw state, fetch, zEqual
    dw nesting, fetch, zEqual
    dw and
    cIf
        dw here, fetch                  ; TOS = here
        dw lit, rst08_opcode, ccomma    ; write z80 jp opcode to word
    cEndIf
    dw nestPlus                         ; increase nesting
    EXIT                             ; return from the function.

defword "}",1,msk_immed,rbrace
    rst $08                             ; enter forth
    dw nestMinus                        ; reduce nesting
    dw state, fetch, zEqual
    dw nesting, fetch, zEqual
    dw and
    cIf
        dw lit, exit, comma                 ; append exit (so the word will return).
    cEndIf
    EXIT                             ; return from the function.

defword "}exec",5,msk_immed,rbraceExec
    rst $08                             ; enter forth
    dw rbrace
    dw state, fetch, zEqual
    dw nesting, fetch, zEqual
    dw and
    cIf
        dw dup
        dw here, store
        dw execute
    cEndIf
    EXIT                             ; return from the function.

defword "stack",6,0,stackColon          ; ( n -- addr ) allocates memory and puts pointer at 0
    rst $08                             ; enter forth
    dw twoPlus, allot                   ; allocate n + 2 bytes, push addr
    dw dup                              ; addr -- addr addr
    dw dup, twoPlus, swap, store        ; addr addr -- addr
    EXIT

defword "stackPush",5,0,stackPush       ; value stack --
    rst $08                             ; enter forth
    dw dup, nrot                        ; value stack - stack value stack
    dw fetch, dup, nrot                 ; stack value ptr -- stack ptr value ptr
    dw store                            ; stack ptr value ptr -- stack ptr
    dw twoplus, swap, store             ; stack ptr --
    EXIT

defword "stackPop",5,0,stackPop         ; stack -- value
    rst $08                             ; enter forth
    dw dup                              ; stack -- stack stack
    dw fetch, dup                       ; stack stack -- stack ptr ptr
    dw fetch, nrot                      ; stack ptr ptr -- value stack ptr
    dw twominus, swap                   ; value stack ptr -- value ptr stack
    dw store
    EXIT

defword "S[",2,0,beginFrame    ; begin a stack frame
    rst $08                             ; enter forth
    dw framePtr, dup                    ;  -- addr addr
    dw fetch, swap                      ; addr addr -- framePtr0 addr
    dw spfetch, swap                    ; framePtr0 attr -- framePtr0 paramSP addr
    dw store                            ; framePtr0 paramSP addr -- framePtr0
    EXIT                             ; TOS = framePtr0

defword "]S",2,0,endFrame        ; end a stack frame
    rst $08                             ; enter forth
                                        ; TOS = framePtr0
    dw framePtr, store                  ; store TOS in framePtr
    EXIT

defword "param",5,0,param               ; n -- addr return addr of param n, -ve args, +ve locals
    rst $08                             ; enter forth
    dw oneminus, cells                            ; n *= 2
    dw framePtr, fetch, plus
    EXIT

defword "p1",2,0,p1                     ;  -- p1addr
    rst $08                             ; enter forth
    dw lit, -1, param, fetch
    EXIT

defword "p2",2,0,p2                     ;  -- p2addr
    rst $08                             ; enter forth
    dw lit, -2, param, fetch
    EXIT

defword "p3",2,0,p3                     ;  -- p3addr
    rst $08                             ; enter forth
    dw lit, -3, param, fetch
    EXIT

defword "v1",2,0,v1                     ;  -- v1addr
    rst $08                             ; enter forth
    dw lit, 1, param
    EXIT

defword "v2",2,0,v2                     ;  -- v2addr
    rst $08                             ; enter forth
    dw lit, 2, param
    EXIT

defword "v3",2,0,v3                     ;  -- v3addr
    rst $08                             ; enter forth
    dw lit, 3, param
    EXIT
